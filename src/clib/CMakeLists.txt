# generate grackle_float.h AND auto_general.c
# ===========================================

# TODO: if they exist, delete ${CMAKE_CURRENT_SOURCE_DIR}/grackle_float.h AND
# ${CMAKE_CURRENT_SOURCE_DIR}/auto_general.c
# -> this probably isn't necessary, but it certainly makes things less confusing

# first, declare recipe for generating grackle_float.h:
if (GRACKLE_USE_DOUBLE)
  set(GRACKLE_FLOAT_MACRO "GRACKLE_FLOAT_8")
else()
  set(GRACKLE_FLOAT_MACRO "GRACKLE_FLOAT_4")
endif()
configure_file(grackle_float.h.in grackle_float.h @ONLY)

# next, declare recipe for generating auto_general.c:

# fetch necessary version information via query-version.py script
# -> GIT_BRANCH and GIT_REVISION hold sensible vals when git isn't installed
# -> VERSION_NUM may hold more information than Grackle_VERSION (e.g. like the
#    "dev" suffix)

set(_query_version "${CMAKE_CURRENT_SOURCE_DIR}/../../config/query-version.py")
function(query_version option OUTVAR)
  execute_process(
      COMMAND ${_query_version} ${option}
      RESULT_VARIABLE RSLT OUTPUT_VARIABLE OUT
      OUTPUT_STRIP_TRAILING_WHITESPACE
  )
  if(result)
    message(FATAL_ERROR "Call to `${_query_version} ${option}` failed")
  endif()
  set(${OUTVAR} ${OUT} PARENT_SCOPE)
endfunction()

query_version(show-version VERSION_NUM)
query_version(git-branch GIT_BRANCH)
query_version(git-revision GIT_REVISION)

# in the original build-system, the following string also included things like:
# include-args, linking flags, macro definitions, all other compiler flags...
string(REPLACE "\n" "\\n" SHOW_FLAGS_STR "
  CC = ${CMAKE_C_COMPILER}
  FC = ${CMAKE_Fortran_COMPILER}
  LD = ${CMAKE_LINKER}
")

string(REPLACE "\n" "\\n" SHOW_CONFIG_STR "
   Built with CMake

   GRACKLE_USE_DOUBLE                  : ${GRACKLE_USE_DOUBLE}
   GRACKLE_USE_OPENMP                  : ${GRACKLE_USE_OPENMP}
   BUILD_TYPE                          : ${CMAKE_BUILD_TYPE}
")

configure_file(auto_general.c.in auto_general.c @ONLY)

# Get the list of source files
# ============================
# - TODO: consider explicitly listing files rather than using this glob-based
#   appraoch. This glob-based approach isn't recommended by the authors of
#   CMake.
# - Some disadvantages of this approach are mitigated by inclusion of the
#   CONFIGURE_DEPENDS flag.
file(GLOB concrete_c_src_list CONFIGURE_DEPENDS *.c)
file(GLOB concrete_hdr_list CONFIGURE_DEPENDS
  *grackle_chemistry_data_fields.def *.h)
file(GLOB concrete_f_src_list CONFIGURE_DEPENDS *.F)
file(GLOB f_interface_list CONFIGURE_DEPENDS *.def)

# remove any auto-generated files detected from the source-directory (these
# would be produced by other build system).
list(FILTER concrete_c_src_list EXCLUDE REGEX "/?auto_.*")
list(FILTER concrete_hdr_list EXCLUDE REGEX "/?grackle_float.h")

# move grackle_chemistry_data_fields.def from f_interface_list to hdr_list
list(FILTER
  f_interface_list EXCLUDE REGEX "/?grackle_chemistry_data_fields.def")
list(APPEND concrete_hdr_list grackle_chemistry_data_fields.def)

# Declare the main target
# =======================

# NOTE: we need to explicitly list out the auto-generated header file(s) (i.e.
# they can't be part of a list of dependencies) in order to let CMake know that
# the auto-generated header is a dependency (and so that it knows to use the
# auto-generated header while identifying dependencies of object files). For
# consistency, we also explicitly list out the autogenerated source files
#
# A subtle/silent bug can occur, when a previous build was installed in a
# standard system location, like /usr/local, and the auto-generated header(s)
# are not explicitly listed out (i.e. they're instead included in a list with
# other files). In that scenario, CMake doesn't realize it needs to generate
# the header(s) and the compiler thinks everything is fine because it can find
# the version of the header generated in an older version of the build in the
# standard system search path
add_library(Grackle_Grackle
  ${concrete_c_src_list} ${concrete_f_src_list} ${concrete_header_list}
  ${CMAKE_CURRENT_BINARY_DIR}/auto_general.c
  ${CMAKE_CURRENT_BINARY_DIR}/grackle_float.h)

# A downstream application built with CMake generally has 2 inclusion
# approaches (ways that they can make use of this build):
#    1. they can build Grackle as part of the downstream build.
#       - in this case, the downstream build calls add_subdirectory on the top
#         level directory of Grackle and they can access the targets defined in
#         this file.
#    2. they can use the installed library
#       - in this case, the downstream build will get access to the targets
#         defined in a special CMake export-file created during installation
#
# We take some care to make these approaches as interchangable as possible for
# downstream build. To that end, we take 2 primary steps:
#
# - we name the main target Grackle_Grackle, rather than just [Gg]rackle to
#   minimize the chance for name-collisions of targets created by the build of
#   the downstream application (this is relevant for approach #1)
#
# - Following existing conventions, the downstream project should access the
#   target called Grackle::Grackle. We make use of a namespace to follow
#   convention... (they are more useful if we built multiple targets as part of
#   the build)
add_library(Grackle::Grackle ALIAS Grackle_Grackle) # for inclusion appraoch #1

set_target_properties(Grackle_Grackle PROPERTIES
  # ensure that the resulting library is named libgrackle(.so)|(.a):
  OUTPUT_NAME grackle
  # specify target name made available that is made visible in inclusion
  # approach #2. The namespace-prefix of this target, "Grackle::", is declared
  # down below in install(EXPORT ...)
  EXPORT_NAME Grackle
)

target_include_directories(Grackle_Grackle
  # specify where to search for generated and ordinary headers when building
  # grackle AND when linking against grackle under inclusion approach #1
  # -> while it may seem unnecessary to specify the ordinary headers' directory
  #    while building grackle, it's necessary to compile auto_general.c
  PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}> # generated hdrs
         $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}> # hdrs in src directory

  # specify where to search for the other headers when linking against grackle
  # (for inclusion approach #2)
  INTERFACE $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
)

# the following variable is an abbreviated shorthand used in "generator
# expressions" used to conditionally apply properties/compiler-flags to all
# source-code files the compose a build-target based on whether or not a given
# source-code file is written in Fortran
set(is_FC "$<COMPILE_LANGUAGE:Fortran>")

target_link_libraries(Grackle_Grackle
  PRIVATE GRACKLE_HDF5_C
          $<$<BOOL:${GRACKLE_USE_OPENMP}>:OpenMP::OpenMP_Fortran>
          $<$<BOOL:${GRACKLE_USE_OPENMP}>:OpenMP::OpenMP_C>
)

set(GRACKLE_FC_FLAG "")
# do some (non-exhaustive) handling of the fortran-specific flags!
if (CMAKE_FORTRAN_COMPILER_ID STREQUAL "PGI")
  list(APPEND GRACKLE_FC_FLAG "-Mnosecond_underscore" "-Mextend")
else()
  include(CheckFortranCompilerFlag)
  check_fortran_compiler_flag(-fno-second-underscore no_second_underscore)
  check_fortran_compiler_flag(-ffixed-line-length-132 fixed_line_length_132)
  list(APPEND GRACKLE_FC_FLAG
    "$<$<BOOL:${no_second_underscore}>:-fno-second-underscore>"
    "$<$<BOOL:${fixed_line_length_132}>:-ffixed-line-length-132>"
  )
endif()

target_compile_options(Grackle_Grackle PRIVATE "$<${is_FC}:${GRACKLE_FC_FLAG}>")

# handle fortran name-mangling macros (TODO: cmake's FortranCInterface module?)
if ("${CMAKE_SYSTEM_NAME}" MATCHES "^(Linux)|(Darwin)$")
  target_compile_definitions(Grackle_Grackle PRIVATE "$<$<NOT:${is_FC}>:LINUX>")
endif()

# If we are building a shared library, construct a "configuration Makefile"
# that is used to build the code examples
# - we're mostly just doing this to let us run the code examples as part of the
#   pytest test suite (hence why we only do this for shared libraries)
if (BUILD_SHARED_LIBS)
  include(CreateExampleConfigMakefile)
  create_example_config_Makefile(
    "Make.examples-config" "Grackle::Grackle" "${GRACKLE_FC_FLAG}"
  )
endif()

# In the short term, we have explicitly commented out the following code, which
# deals with installation and creation of a "Config Package File" for a few
# reasons:
#  - most importantly, it's unneeded right now. Currently this cmake build
#    system is all fairly experimental and it only exists to facillitate
#    embedding of the library within other projects
#  - setting up installation of the library file and headers isn't hard. But,
#    we would need to decide just how closely we want to mirror the libtool
#    approach (which renames the library). Closely mirroring libtool would
#    introduce some complexity
#  - creating a "Config Package File" is a little complicated
#    - This is a file, that we would name GrackleConfig.cmake, that would help
#      other cmake projects link against the installed grackle libraries.
#      Among other things, it determines any compiler flags that grackle needs
#      to use
#    - This is totally unnecessary if we are embedding grackle within another
#      project. But, it would probably be good to provide this even if we
#      ultimately remove the cmake build system.
#    - it's a little complicated to get this right. In particular, it needs to
#      conditionally identify any transitive dependencies based on whether
#      the downstream user wants to use the shared or static library (and the
#      dependency list depends on whether grackle is compiled with openmp)
#    - it's also somewhat important to ensure that the package file provides
#      the same experience as directly embedding grackle

## Handle Installation Considerations
## ==================================
## Here we instruct CMake about what needs to be done during installation
## NOTE: users can influence the installation prefix directory separately
##       Within that prefix directory
#
## installation of public header files
## (NOTE: it may make sense to reorganize the source directory so that these
## are more easily identified
#set(public_hdr_list ${concrete_hdr_list})
#list(FILTER public_hdr_list INCLUDE REGEX "grackle[^/]*.h")
#install(FILES ${f_interface_list} ${public_hdr_list}
#  ${CMAKE_CURRENT_BINARY_DIR}/grackle_float.h
#  TYPE INCLUDE)
#
#
## install the main library target
## -> EXPORT associates this target with the GrackleTargets export set
#install(TARGETS Grackle_Grackle
#  EXPORT GrackleTargets
#  DESTINATION ${CMAKE_INSTALL_LIBDIR}
#)
#
## generate and installs a file containing CMake code code that declares targets
## for all export-key
## - currently, only 1 target is associated with that export key
## - all targets in that file will be in the Grackle:: namespace
#install(EXPORT GrackleTargets
#  DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/Grackle
#  NAMESPACE Grackle::
#)
